---
title: "VarSel"
author: "Arnie Seong"
date: "`r format(Sys.time(), '%d %B %Y')`"
header-includes:
  - \usepackage{bm}
- \usepackage{xcolor}
- \usepackage{amssymb}
output: 
  html_document:
    df_print: paged
    theme: cerulean
    highlight: tango
    toc: yes
    toc_depth: 4
    toc_float:
      collapsed: false
      smooth_scroll: true
code_fold: hide
urlcolor: blue
---
  
  
```{r setup, include=FALSE, message=F, echo=F, warning=F}
# LIBRARIES----
library(reticulate)
use_condaenv("BayesCompress")

#### plotting:
library(ggplot2)
library(gridExtra)

#### Misc:
library(here)
library(dplyr)
library(tidyr)
library(knitr)
library(kableExtra)

# DOCUMENT SETUP ----
#### detect pdf/html output, set chunk options, sci.notation 
latex_out <- knitr::is_latex_output()
knitr::opts_chunk$set(
  cache = FALSE, 
  message = FALSE, 
  echo = !knitr::is_latex_output(), 
  warning = FALSE
)
if (knitr::is_latex_output()) {
  knitr::opts_chunk$set(fig.height=4, 
                        fig.width=6)
} else {
  knitr::opts_chunk$set(out.width = "100%")
}
options(scipen=10)

# TEXT/TABLE FORMATTING----
purple <- ifelse(
  knitr::is_latex_output(),
  "purple",
  "#b51ced"
)

blue <- ifelse(
  knitr::is_latex_output(),
  "blue",
  "#11579e"
)

colorize <- function(x, color=purple) {
  # text color conditional on latex/html output
  # from rmarkdown cookbook
  if (knitr::is_latex_output()) {
    sprintf("\\textcolor{ %s}{ %s}", color, x)
  } else if (knitr::is_html_output()) {
    sprintf("<span style='color: %s;'>%s</span>", color, x)
  } else x
}


#### kable NA handling
options(knitr.kable.NA = '')

#### detect if knitting
knitting <- !is.null(getOption("knitr.in.progress"))

#### mykable
mykable <- function(tab, cap = NULL,
                    latex_options=c("hold_position", "scale_down", "striped"), 
                    bootstrap_options=c("striped", "hover", "condensed"), 
                    full_width=F, position="center", ...){
  # kable formatting conditional on latex or html output
  # common additional unspecified args (...):
  #     digits = 2
  #     format.args = (list(big.mark = ","))
  if (is.null(getOption("knitr.in.progress"))){
    print(tab)
  } else if (knitr::is_latex_output()){
    kable(x=tab, caption=cap, ...) %>%
      kableExtra::kable_styling(latex_options = latex_options)
  } else if (knitr::is_html_output()){
    kable(x=tab, caption=cap, ...) %>%
      kableExtra::kable_styling(bootstrap_options = bootstrap_options, full_width=full_width, position=position)
  }
}
```





# generate data

## linear data

Choose from normal & binomial distributions, select variables, make $y$ a linear transformation of selected vars, return dataframe.

```{r generate_linear_data_func}

generate_linear_data <- function(
    ave_beta = 2,
    sd_beta = 10,
    sd_eps = 1,
    n_obs = 1E4,
    n_covars = 10,
    n_nuisance = 20
  ){
  
  beta_vec <- round(rnorm(n_covars + 1, mean = ave_beta, sd = sd_beta), 2)
  dat <- data.frame(matrix(0, nrow = n_obs, ncol = n_covars + n_nuisance))
  distn_vec <- rep(NA, n_covars + n_nuisance)
  
  for (j in 1:(n_covars+n_nuisance)) {
    distn <- sample(c("normal","binomial"), 1)
    if (distn == "normal"){
      mu_j <- floor(runif(1, 0, 10))
      sig_j <- floor(runif(1, 1, 5))
      dat[, j] <- rnorm(n_obs, mu_j, sig_j)
      distn_vec[j] <- paste0(distn, "(", mu_j, ", ", sig_j, ")")
      
    } else if (distn == "binomial"){
      p_j <- round(runif(1, 0.1, 1), 1)
      n_j <- floor(runif(1, 1, 10))
      dat[,j] <- rbinom(n_obs, size = n_j, prob = p_j)
      distn_vec[j] <- paste0(distn, "(", n_j, ", ", p_j, ")")
    }
  }
  
  # construct y
  dat <- round(dat, 2)
  covar_inds <- sort(sample(1:(n_covars + n_nuisance), n_covars))
  covars <- as.matrix(dat[, covar_inds])
  covar_distns <- distn_vec[covar_inds]
  eps <- rnorm(n_obs, mean = 0, sd = sd_eps)
  dat$y <- as.vector(cbind(1, covars) %*% beta_vec + eps)
  true_covars <- colnames(dat)[covar_inds]
  nuisance_vars <- colnames(dat)[setdiff(1:(n_nuisance + n_covars), covar_inds)]
  names(beta_vec) <- c("(Intercept)", true_covars)
  
  res <- list(
    "dat" = dat,
    "eps" = eps,
    "sd_eps" = sd_eps,
    "distn_vec" = distn_vec,
    "n_obs" = n_obs,
    "n_covars" = n_covars,
    "n_nuisance" = n_nuisance,
    "beta_vec" = beta_vec,
    "covar_inds" = covar_inds,
    "true_covars" = true_covars,
    "nuisance_vars" = nuisance_vars
  )
  
  return(res)
}

```


### visualize

```{r}
lindat_obj <- generate_linear_data()
dat <- lindat_obj$dat
true_covars <- lindat_obj$true_covars
nuisance_vars <- lindat_obj$nuisance_vars
covar_inds <- lindat_obj$covar_inds
beta_vec <- lindat_obj$beta_vec

dat %>% 
  slice_sample(n = 500) %>% 
  gather(key = "covar", value = "value", -y) %>% 
  mutate(true_cov = if_else(
    covar %in% lindat_obj$true_covars,
    "covar_true",
    "nuisance"
    )
  ) %>% 
  ggplot() + 
  geom_density(
    aes(
      x = value,
      color = covar,
      fill = covar,
      alpha = I(ifelse(true_cov=="covar_true", .25, .1))
    )
  )


dat %>% 
  slice_sample(n = 500) %>% 
  gather(key = "covar", value = "value", -y) %>% 
  mutate(true_cov = if_else(
    covar %in% lindat_obj$true_covars,
    "covar_true",
    "nuisance"
    )
  ) %>% 
  ggplot() + 
  geom_point(
    aes(
      y = y,
      x = value,
      color = covar,
      alpha = I(ifelse(true_cov=="covar_true", .25, .1))
    )
  ) + 
  geom_smooth(
    aes(
      y = y,
      x = value
    ),
    method = 'lm'
  )
```



```{r}
ols_varsel_err <- function(lmfit, true_covars, nuisance_vars, thresh = 0.05){
  TP <- sum(summary(lmfit)$coef[true_covars, 4] < thresh)
  FN <- sum(summary(lmfit)$coef[true_covars, 4] >= thresh)
  TN <- sum(summary(lmfit)$coef[nuisance_vars, 4] >= thresh)
  FP <- sum(summary(lmfit)$coef[nuisance_vars, 4] < thresh)
  return(
    list(
      TP = TP,
      FN = FN,
      TN = TN,
      FP = FP
    )
  )
}

lmfit <- lm("y ~ .", data = dat)
ols_varsel_err(lmfit, true_covars, nuisance_vars)
```





## make pytorch data loader

```{r python_env_setup, echo = FALSE}
# set file path
fpath <- here::here()
setwd(fpath)
# py_install("scikit-image", pip = TRUE)
```




```{python load_python_libs}
from __future__ import print_function, division
import os
import torch
import pandas as pd
from skimage import io, transform
import numpy as np
import matplotlib.pyplot as plt
from torch.utils.data import Dataset, DataLoader
from torchvision import transforms, utils

loader = DataLoader(r.dat, batch_size = 50, shuffle = True, num_workers = 4)
for i, batch in enumerate(loader):
  print(i, batch)

```



```{python make_data_loader}


```



Need to write a data loader, then figure out the network layers















```{python load_libs}

```




















